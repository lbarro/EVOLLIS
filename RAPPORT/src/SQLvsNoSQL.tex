Il serait tout à fait légitime de penser que le 
\textsf{NoSQL} soit là pour remplacer les \textsf{BDDR}
classiques. Mais ceci est difficilement imaginable de
nos jours. L’intérêt pour le \textsf{NoSQL} s'est considérablement
accru à l'issu des annonces d’adoption de ces technologies par les 
grands acteurs d'\textsf{Internet} tels 
\textsf{Google} et \textsf{Facebook} qui se sont multipliées. Ces acteurs
n'ont pas pour autant abandonné \textsf{BDDR}. \textsf{Google} et 
\textsf{Facebook} utilisent \textsf{MySQL}\cite{mysqlcustomers}.
\\
\\
Ci-dessous quelques traitements auxquels le modèle relationnel
classique ne répond pas et qui pourrait motiver le recours aux
technologies \textsf{NoSQL}\index{Limites du \textsf{SQL}}:

%% \paragraph{Indexation d'une quantité de documents:}
%% Un problème se pose quant à l'indexation d'une quantité importante de
%% données. Par exemple pour le \textsf{SGBD} \textsf{SQL Server}, la
%% version $2008$ supporte au plus $999$ indexes et chaque index, chaque
%% index peut couvrir au maximum 16 colonnes et la somme des tailles des
%% colonnes couvertes ne doit pas excéder $900\ octets$\cite{SQLserver}

\paragraph{Environnement distribué:} pour faire face à des volumes importants 
de données, il est possible de les repartir sur différentes machines physiques. 
Pour avoir plusieurs points d'accès aux données, il est nécessaire de les dupliquer
sur différents serveurs. Toutes ces opérations constitue en la mise en place d'un 
environnement distribué. Les \textsf{SGBDR} classiques montre des limites dans un 
environnement distribué.\cite{} 

\paragraph{Données de tailles variables selon les enregistrements:} Les 
\textsf{BDDR} classiques prévoient un schéma statique à 
l'avance. Le schéma est organisé en tables de données où les lignes 
contiennent les mêmes types et nombre de colonnes. Celles-ci n'offrent donc 
pas un environnement dynamique pour les enregistrements.

\paragraph{Réécritures fréquentes:}  en effet, les \textsf{SGBDR} classiques en générale
appliquent la consistance forte et ce grâce aux propriétés \textsf{ACID}. 
Je l'ai tantôt dit, ces opérations sont à l'origine d'\textit{overhead} 
et sont appliquées même pour les opérations simples d'écriture dans la base. Ceci diminuera
considérablement la performance en cas de réécritures fréquentes des données même pour
les opérations simples.
Les \textsf{BDDR} mettent en avant un système d'indexation très évolué. L'utilisation
d'indexes est plutôt conseillée pour les systèmes où l'accès en écriture est
beaucoup plus important que celui en écriture. Tout ceci laisse penser que le modèle relationnel
classique prévoit plus de lectures que d'écritures. 

\paragraph{Extensibilité de la base:} Comme signaler à la section \ref{carac}, 
la scalabilité horizontale qui est l'une des caractéristiques principales 
des solutions \textsf{NoSQL}, offre la possibilité 
d'ajouter des nœuds au cluster pour gagner en performance. Les \textsf{SGBDR} classiques 
n'ont pas cette propriété de scalabilité horizontale.
\\ 
\\ 
Sans doute, l'extensibilité requise et la grande quantité de données
et de mises à jour rendent le modèle relationnel inefficace ce qui a
obligé à trouver un nouveau modèle.  Face à ces encouragements en
l'occurrence ceux énumérés ci-dessus, on serait tenter d'adopter sans
équivoque le \textsf{NoSQL}. Cependant il est important de prendre ne
considération quelques aspects au risque d'une mauvaise utilisation. «
L’intérêt d’une base de données \textsf{NoSQL} pour un projet ne
dépend pas du volume de données qu’elle aura à manipuler. Le choix de
son utilisation doit être basé sur la préférence d’un mode de
représentation et non sur une forte volumétrie
»\cite{NoSQLeurope}. Aussi, Ne devrions-nous pas oublier que cette
catégorie de produits, fait le compromis d'abandonner certaines
fonctionnalités classiques des \textsf{SGBD} relationnels au profit de
la performance. Par conséquent, il ne s’agit donc pas d’une solution
miracle pour tout type de stockage de données.  La tentative de
reproduire dans une base de données \textsf{NoSQL} une représentation
ou un comportement habituellement offert par un \textsf{SGBD}
relationnels aboutira probablement à une solution peu efficace.
\\
\\
Dan McCreary a également convenu avec Michael Stonebraker que les
utilisateurs NoSQL ne partagent pas un langage de requête unifiée, ce
qui va ralentir l'adoption de NoSQL\cite{SergeLeblal}.
\\
\\
Relational databases work best with structured data—such as a set of
sales figures—which readily fits in well-organized tables. This is not
the case with unstructured data, such as that found in word-processing
documents and images\cite{NealLeavitt}.
\newpage
\noindent Précédemment, j'ai mentionné que le \textsf{NoSQL} a renoncé à la consistance
pour plus de performances et de scalabilité. Ceci n'est pas sans compromis, notamment 
la reprise sur erreurs. \textsf{Michael Stonebraker} explique clairement sur 8 cas d'erreurs 
les enjeux du choix
des propriétés \textsf{CAP}\cite{MichaelStonebraker}. Je me limiterai seulement à
3 cas. Le but étant de mettre en relief les limites d'une « \textsf{consistance éventuelle} »
et d'exhiber deux situations qui rendent impossible la propriété \textsf{A} de \textsf{CAP}.
%===========================================================
%     Illustration enjeux du choix de AP dans CAP
%===========================================================
\def\exemple{We assume a typical hardware model of a
collection of local processing and storage nodes assembled into a cluster using LAN networking.
The clusters, in turn, are wired together using WAN networking.
Let’s start with a discussion of what causes errors in databases. Je considère les trois cas d'erreur suivants:}

\def\casa{Application errors. The application performed one or more incorrect updates. Generally, this is
not discovered for minutes to hours thereafter. The database must be backed up to a point before the offending transaction(s), and subsequent activity redone.}

\def\casb{Repeatable DBMS errors. The DBMS crashed at a processing node. Executing the same
transaction on a processing node with a replica will cause the backup to crash. These errors have
been termed Bohr bugs.}

\def\casc{\sf A disaster. The local cluster is wiped out by a flood, earthquake, etc. The cluster no longer exists.}

\begin{center}
\begin{tabular}{p{1.7cm} p{12cm}}
\multicolumn{2}{p{14cm}}{\sf \exemple}\\&\\  
{\bf Cas 1}  & \textsf{\casa}\\~&~\\
{\bf Cas 2}  & \textsf{\casb}\\~&~\\
{\bf Cas 3}  & \textsf{\casc}\\
\end{tabular}
\end{center}
\noindent
First, note that errors 1 and 2 will cause problems with any high availability scheme. In these two
scenarios, there is no way to keep going; i.e., availability is impossible to achieve. Also, replica
consistency is meaningless; the current DBMS state is simply wrong. Error 7 will only be
recoverable if a local transaction is only committed after the assurance that the transaction has
been received by another WAN-connected cluster. Few application builders are willing to accept this kind of latency. Hence, eventual consistency cannot be guaranteed, because a transaction
may be completely lost if a disaster occurs at a local cluster before the transaction has been
successfully forwarded elsewhere. Put differently, the application designer chooses to suffer data
loss when a rare event (such as a disaster) occurs, because the performance penalty for avoiding it is too high.


