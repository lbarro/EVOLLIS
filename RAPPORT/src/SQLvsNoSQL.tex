Il serait tout à fait légitime de penser que le 
\textsf{NoSQL} soit là pour remplacer les \textsf{BDDR}
classiques. Mais ceci est difficilement imaginable de
nos jours. L’intérêt pour le \textsf{NoSQL} s'est considérablement
accru à l'issu des annonces d’adoption de ces technologies par les 
grands acteurs d'\textsf{Internet} tels 
\textsf{Google} et \textsf{Facebook} qui se sont multipliées. Ces acteurs
n'ont pas pour autant abandonné \textsf{BDDR}. \textsf{Google} et 
\textsf{Facebook} utilisent \textsf{MySQL}\cite{mysqlcustomers}.
\\
\\
Ci-dessous quelques traitements auxquels le modèle relationnel
classique ne répond pas et qui pourrait motiver le recours aux
technologies \textsf{NoSQL}\index{Limites du \textsf{SQL}}:

%% \paragraph{Indexation d'une quantité de documents:}
%% Un problème se pose quant à l'indexation d'une quantité importante de
%% données. Par exemple pour le \textsf{SGBD} \textsf{SQL Server}, la
%% version $2008$ supporte au plus $999$ indexes et chaque index, chaque
%% index peut couvrir au maximum 16 colonnes et la somme des tailles des
%% colonnes couvertes ne doit pas excéder $900\ octets$\cite{SQLserver}

\paragraph{Environnement distribué:} pour faire face à des volumes importants 
de données, il est possible de les repartir sur différentes machines physiques. 
Pour avoir plusieurs points d'accès aux données, il est nécessaire de les dupliquer
sur différents serveurs. Toutes ces opérations constitue en la mise en place d'un 
environnement distribué. Les \textsf{SGBDR} classiques montre des limites dans un 
environnement distribué. Ces {SGBD} ne sont pas destinés à fonctionner dans un
environnement à données reparties du fait de l'opération de jointure
qui est difficilement réalisable entre des tables réparties sur des systèmes différents\cite{RickCattell}.
Les \textsf{SGBDR} classiques effectuent également des opérations impliquant de la distribution des données
mais ces opérations ne sont pas du type « \textit{shared nothing} ». Les coeurs et les processus impliqués
dans ces opérations se partagent mutuellement la \textsf{RAM} et l'espace disque mémoire.

\paragraph{Données à structure dynamique et libre:} Les 
\textsf{BDDR} classiques prévoient un schéma statique à 
l'avance. Le schéma est organisé en tables de données où les lignes
contiennent les mêmes types et nombre de colonnes. Celles-ci n'offrent
donc pas un environnement dynamique pour les enregistrements. Aussi
les \textsf{SGBDR} fonctionnent avec des données structurées
organisables en tables.  Ce n'est pas le cas avec des données non
structurées, telles les données de traitement de texte et les images
\cite{NealLeavitt}.

\paragraph{Réécritures fréquentes:}  en effet, les \textsf{SGBDR} classiques en générale
appliquent la consistance forte et ce grâce aux propriétés \textsf{ACID}. 
Je l'ai tantôt dit, ces opérations sont à l'origine d'\textit{overhead} 
et sont appliquées même pour les opérations simples d'écriture dans la base. Ceci diminuera
considérablement la performance en cas de réécritures fréquentes des données même pour
les opérations simples.
Les \textsf{BDDR} mettent en avant un système d'indexation très évolué. L'utilisation
d'indexes est plutôt conseillée pour les systèmes où l'accès en écriture est
beaucoup plus important que celui en écriture. Tout ceci laisse penser que le modèle relationnel
classique prévoit plus de lectures que d'écritures. 

\paragraph{Extensibilité de la base:} Comme signaler à la section \ref{carac}, 
la scalabilité horizontale qui est l'une des caractéristiques principales 
des solutions \textsf{NoSQL}, offre la possibilité 
d'ajouter des nœuds au cluster pour gagner en performance. Les \textsf{SGBDR} classiques 
n'ont pas cette propriété de scalabilité horizontale.
\\ 
\\ 
L'extensibilité requise et la grande quantité de données
et de mises à jour rendent le modèle relationnel inefficace, ce qui a
obligé à trouver un nouveau modèle. Cependant il est important de prendre en
considération quelques aspects au risque d'une mauvaise utilisation. «
L’intérêt d’une base de données \textsf{NoSQL} pour un projet ne
dépend pas du volume de données qu’elle aura à manipuler. Le choix de
son utilisation doit être basé sur la préférence d’un mode de
représentation et non sur une forte volumétrie
»\cite{NoSQLeurope}. Il ne s’agit donc pas d’une solution
miracle pour tout type de stockage de données.  La tentative de
reproduire dans une base de données \textsf{NoSQL} une représentation
ou un comportement habituellement offert par la représentation en tables
n'aboutira pas à une solution plus efficace car l'architecture des 
\textsf{SGBDR} y est exclusivement destinée.
%Dan McCreary a également convenu avec Michael Stonebraker que les
%utilisateurs NoSQL ne partagent pas un langage de requête unifiée, ce
%qui va ralentir l'adoption de NoSQL\cite{SergeLeblal}.
\\
\\
Aussi il est important de garder à l'esprit, comme mentionné avant, 
que le \textsf{NoSQL} a renoncé à la consistance
pour plus de performances et de scalabilité. Ceci n'est pas sans compromis, notamment 
la reprise sur erreurs. 
\textsf{Michael Stonebraker} explique clairement sur 8 cas d'erreurs 
les enjeux du choix
des propriétés \textsf{CAP}\cite{MichaelStonebraker}. Je me limiterai seulement à
3 cas. Le but étant de mettre en relief les limites d'une « \textsf{consistance éventuelle} »
et d'exhiber deux situations qui rendent impossible la propriété \textsf{A} de \textsf{CAP}.
%===========================================================
%     Illustration enjeux du choix de AP dans CAP
%===========================================================
\def\exemple{We assume a typical hardware model of a
collection of local processing and storage nodes assembled into a cluster using LAN networking.
The clusters, in turn, are wired together using WAN networking.
Let’s start with a discussion of what causes errors in databases:}

\def\exempleA{. Je considère les trois cas d'erreur suivants:}

\def\casa{Application errors. The application performed one or more incorrect updates. Generally, this is
not discovered for minutes to hours thereafter. The database must be backed up to a point before the offending transaction(s), and subsequent activity redone.}

\def\casb{Repeatable DBMS errors. The DBMS crashed at a processing node. Executing the same
transaction on a processing node with a replica will cause the backup to crash. These errors have
been termed Bohr bugs.}

\def\casc{\sf A disaster. The local cluster is wiped out by a flood, earthquake, etc. The cluster no longer exists.}

\def\commentA{First, note that errors 1 and 2 will cause problems with any high availability scheme. In these two
scenarios, there is no way to keep going; i.e., availability is impossible to achieve. Also, replica
consistency is meaningless; the current DBMS state is simply wrong. Error 7 will only be
recoverable if a local transaction is only committed after the assurance that the transaction has
been received by another WAN-connected cluster. Few application builders are willing to accept this kind of latency. Hence, eventual consistency cannot be guaranteed, because a transaction
may be completely lost if a disaster occurs at a local cluster before the transaction has been
successfully forwarded elsewhere. Put differently, the application designer chooses to suffer data
loss when a rare event (such as a disaster) occurs, because the performance penalty for avoiding it is too high.}

\def\comment{}

\begin{center}
\begin{tabular}{p{1.7cm} p{12cm}}
\multicolumn{2}{p{14cm}}{\sf \exemple}\\&\\  
{\bf Cas 1}  & \textsf{\casa}\\~&~\\
{\bf Cas 2}  & \textsf{\casb}\\~&~\\
{\bf Cas 3}  & \textsf{\casc}\\
\end{tabular}
\end{center}
\noindent \comment


