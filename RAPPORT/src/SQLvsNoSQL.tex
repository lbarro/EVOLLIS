On pourrait penser que la mouvance
\textsf{NoSQL} soit là pour remplacer les \textsf{BDD}
relationnelles classiques. Mais ceci est difficilement imaginable de
nos jours. L’intérêt pour le \textsf{NoSQL} s'est considérablement
accru dans le monde des entreprises à l'issu des annonces d’adoption 
de ces technologies par les grands acteurs d'\textsf{Internet} tels 
\textsf{Google} et \textsf{Facebook} qui se sont multipliées. Son bon 
fonctionnement dans des conditions extrêmes lui confère une certaine fiabilité.
\\
\\
Ci-dessous quelques traitements auxquels le modèle relationnel
classique ne répond pas et qui pourrait motiver le recours aux
technologies \textsf{NoSQL}\index{Limites du \textsf{SQL}}:

\paragraph{Indexation d'une quantité de documents:}
Un problème se pose quant à l'indexation d'une quantité importante de
données. Par exemple pour le \textsf{SGBD} \textsf{SQL Server}, la
version $2008$ supporte au plus $999$ indexes et chaque index, chaque
index peut couvrir au maximum 16 colonnes et la somme des tailles des
colonnes couvertes ne doit pas excéder $900\ octets$\cite{SQLserver}

\paragraph{Sites à fort trafic:} Pour faire face à des volumes importants 
de données et y avoir accès à de différents endroit0s du monde, il faut 
pouvoir répliquer ces données sur différentes machines physiques et le 
\textsf{SGBD} relationnel classique montre des limites dans un 
environnement distribué. 

\paragraph{Données de taille variables selon les enregistrements:} Les 
\textsf{BDD} relationnelles classiques prévoient un schéma statique à 
l'avance où dans une table donnée, les lignes sont identiques en type et 
en nombre de colonnes donc offre un environnement non dynamique pour les 
enregistrements.

\paragraph{Réécritures fréquentes:} le modèle classique prévoit plus 
de lectures que d'écritures.

\paragraph{Extensibilité de la base:} Comme signaler plus haut, 
\textsf{Cassandra} qui est un \textsf{NoSQL} offre la possibilité 
d'ajouter facilement des serveurs pour gagner en performance sans modifier 
la structure de la base. Les \textsf{SGBD} relationnels classiques 
n'offrent pas cette possibilité.
\\ 
\\ 
Sans doute, l'extensibilité requise et la grande quantité de données
et de mises à jour rendent le modèle relationnel inefficace ce qui a
obligé à trouver un nouveau modèle.  Face à ces encouragements en
l'occurrence ceux énumérés ci-dessus, on serait tenter d'adopter sans
équivoque le \textsf{NoSQL}. Cependant il est important de prendre ne
considération quelques aspects au risque d'une mauvaise utilisation. «
L’intérêt d’une base de données \textsf{NoSQL} pour un projet ne
dépend pas du volume de données qu’elle aura à manipuler. Le choix de
son utilisation doit être basé sur la préférence d’un mode de
représentation et non sur une forte volumétrie
»\cite{NoSQLeurope}. Aussi, Ne devrions-nous pas oublier que cette
catégorie de produits, fait le compromis d'abandonner certaines
fonctionnalités classiques des \textsf{SGBD} relationnels au profit de
la performance. Par conséquent, il ne s’agit donc pas d’une solution
miracle pour tout type de stockage de données.  La tentative de
reproduire dans une base de données \textsf{NoSQL} une représentation
ou un comportement habituellement offert par un \textsf{SGBD}
relationnels aboutira probablement à une solution peu efficace.
\\
\\
Dan McCreary a également convenu avec Michael Stonebraker que les
utilisateurs NoSQL ne partagent pas un langage de requête unifiée, ce
qui va ralentir l'adoption de NoSQL\cite{SergeLeblal}.
\\
\\
Relational databases work best with structured data—such as a set of
sales figures—which readily fits in well-organized tables. This is not
the case with unstructured data, such as that found in word-processing
documents and images\cite{NealLeavitt}.
\newpage
\noindent Précédemment, j'ai mentionné que le \textsf{NoSQL} a renoncé à la consistance
pour plus de performances et de scalabilité. Ceci n'est pas sans compromis, notamment 
la reprise sur erreurs. \textsf{Michael Stonebraker} explique clairement sur 8 cas d'erreurs 
les enjeux du choix
des propriétés \textsf{CAP}\cite{MichaelStonebraker}. Je me limiterai seulement à
3 cas. Le but étant de mettre en relief les limites d'une « \textsf{consistance éventuelle} »
et d'exhiber deux situations qui rendent impossible la propriété \textsf{A} de \textsf{CAP}.
%===========================================================
%     Illustration enjeux du choix de AP dans CAP
%===========================================================
\def\exemple{We assume a typical hardware model of a
collection of local processing and storage nodes assembled into a cluster using LAN networking.
The clusters, in turn, are wired together using WAN networking.
Let’s start with a discussion of what causes errors in databases. Je considère les trois cas d'erreur suivants:}

\def\casa{Application errors. The application performed one or more incorrect updates. Generally, this is
not discovered for minutes to hours thereafter. The database must be backed up to a point before the offending transaction(s), and subsequent activity redone.}

\def\casb{Repeatable DBMS errors. The DBMS crashed at a processing node. Executing the same
transaction on a processing node with a replica will cause the backup to crash. These errors have
been termed Bohr bugs.}

\def\casc{\sf A disaster. The local cluster is wiped out by a flood, earthquake, etc. The cluster no longer exists.}

\begin{center}
\begin{tabular}{p{1.7cm} p{12cm}}
\multicolumn{2}{p{14cm}}{\sf \exemple}\\&\\  
{\bf Cas 1}  & \textsf{\casa}\\~&~\\
{\bf Cas 2}  & \textsf{\casb}\\~&~\\
{\bf Cas 3}  & \textsf{\casc}\\
\end{tabular}
\end{center}
\noindent
First, note that errors 1 and 2 will cause problems with any high availability scheme. In these two
scenarios, there is no way to keep going; i.e., availability is impossible to achieve. Also, replica
consistency is meaningless; the current DBMS state is simply wrong. Error 7 will only be
recoverable if a local transaction is only committed after the assurance that the transaction has
been received by another WAN-connected cluster. Few application builders are willing to accept this kind of latency. Hence, eventual consistency cannot be guaranteed, because a transaction
may be completely lost if a disaster occurs at a local cluster before the transaction has been
successfully forwarded elsewhere. Put differently, the application designer chooses to suffer data
loss when a rare event (such as a disaster) occurs, because the performance penalty for avoiding it is too high.


